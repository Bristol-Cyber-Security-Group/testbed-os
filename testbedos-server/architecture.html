<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TestbedOS Server Architecture &mdash; testbed-os 1.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=fc837d61"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="TestbedOS Server API" href="api.html" />
    <link rel="prev" title="TestbedOS Server" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            testbed-os
          </a>
              <div class="version">
                1.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting-started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation/index.html">Testbed OS Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testbed-config/index.html">Testbed Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kvm-compose/index.html">kvm-compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../orchestration/index.html">Orchestration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interfaces/index.html">Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guest-types/index.html">Guest Types</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">TestbedOS Server</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">TestbedOS Server Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rest-api">REST API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#systemd-service">Systemd Service</a></li>
<li class="toctree-l3"><a class="reference internal" href="#database-provider">Database Provider</a></li>
<li class="toctree-l3"><a class="reference internal" href="#orchestration">Orchestration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logging">Logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="#log-streaming">Log Streaming</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cluster-management">Cluster Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#developer-notes">Developer Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html">TestbedOS Server API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resource-monitoring/index.html">Resource Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test-harness/index.html">Test Harness</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">testbed-os</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">TestbedOS Server</a></li>
      <li class="breadcrumb-item active">TestbedOS Server Architecture</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/testbedos-server/architecture.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="testbedos-server-architecture">
<h1>TestbedOS Server Architecture<a class="headerlink" href="#testbedos-server-architecture" title="Link to this heading"></a></h1>
<section id="rest-api">
<h2>REST API<a class="headerlink" href="#rest-api" title="Link to this heading"></a></h2>
<p>See API document.</p>
</section>
<section id="systemd-service">
<h2>Systemd Service<a class="headerlink" href="#systemd-service" title="Link to this heading"></a></h2>
<p>The testbedos-server is setup as a service with systemd, its called <cite>testbedos-server.service</cite>.
It is not set to start by default so you must run <cite>sudo systemctl start testbedos-server.service</cite>, but you can make this autostart with <cite>sudo systemctl enable testbedos-server.service</cite> manually.
The setup script and teardown script will manage the install and uninstall for you.</p>
<p>The server is running as a normal HTTP server at the moment, we have aspirations to run this in a socket so that we can protect it with user permissions.</p>
<p>Note that this service will use the default port so if you are developing the server you must disable/stop the systemd service.</p>
</section>
<section id="database-provider">
<h2>Database Provider<a class="headerlink" href="#database-provider" title="Link to this heading"></a></h2>
<p>The server needs a database to store state.
Currently, the server is using a file based architecture that is read/write on demand by the server.
The storage location for this database is in <cite>/var/lib/testbedos/deployments/</cite>.
In the future, if necessary, we can implement a sqlite database.</p>
</section>
<section id="orchestration">
<h2>Orchestration<a class="headerlink" href="#orchestration" title="Link to this heading"></a></h2>
<p>The server will run the orchestration commands depending on the “deployment action” requested by the client.
This deployment action will be passed on to the orchestration tool used internally, see orchestration architecture document for more details.
The execution of this orchestration tool happens inside a long running thread.
Once the orchestration tool has finished, this long running thread will update the database of the server with the outcome of the orchestration.</p>
</section>
<section id="error-handling">
<h2>Error Handling<a class="headerlink" href="#error-handling" title="Link to this heading"></a></h2>
<p>Currently the server has basic error handling which is passed to the user through HTTP error codes.
We have a generic wrapper that returns JSON with the error code and message, usually 500 errors if some business logic does not work.
Some of the errors are not yet fully propagated to the user, this needs some testing of different fail states.</p>
<p>The states of the deployment is recorded in the database, as another form of error recording.
The error codes for each action command is also recorded in the log data file for each log file.</p>
</section>
<section id="logging">
<h2>Logging<a class="headerlink" href="#logging" title="Link to this heading"></a></h2>
<p>Currently the logging is sent to a single file in <cite>/var/lib/testbedos/logs/</cite>, which is overwritten by each server restart.
The log contains all the request information with timestamps.
There is an aspiration to introduce log rotation and cleanup as we expect the server to be running for long periods of time on dedicated hardware.</p>
<p>The server also stores logs for each command actioned on a deployment.
This is stored in <cite>/var/lib/testbedos/logs/orchestration/&lt;iso-date-time&gt;-&lt;project-name&gt;.log</cite>.
There is also a json file with a reference to all the logs for the specific deployment in <cite>/var/lib/testbedos/deployments/&lt;project-name&gt;-logs.json</cite>, that contains the path all the logs in the previous example path.
This is a hashmap/keyvalue store of <cite>uuid:{log_path, error_code}</cite> where the uuid key has a hashmap/keyvalue of the path to the log file and the error code associated with that log.</p>
</section>
<section id="log-streaming">
<h2>Log Streaming<a class="headerlink" href="#log-streaming" title="Link to this heading"></a></h2>
<p>The server provides an endpoint for websockets, specifically to stream the logs of a specific deployment action.
For example, an up command from the CLI will make a request to the server which will set the state of the deployment to “running”, dispatch a blocking thread that handles orchestration and return a uuid.
This uuid is then used by the client to create a websocket session which the server will find the log file and stream line by line until the end of the file.
If the command is still ongoing but the stream has reached the end of the file, the websocket will continue to poll the log file for a new line until the state of the command has changed from “running”.
This way, since usually the orchestration is slower than streaming the logs, the client will keep the websocket open and we avoid time outs on the usual REST calls.
The CLI will then check the state of the deployment on the REST api to see if the command worked or not as there is a success and fail state for each command.</p>
<p>For snapshots, the process is the same as above but with one further check to the log API.
The log API also captures the error code from the command the server executed.
For example, a snapshot command failed with error code 1 - the log api for that uuid will have the error code that the CLI checks to inform the user on the status.</p>
<p>This second step is not currently used for the main commands on the server like UP/DOWN but it can be in the future and for other new commands.
This error code value in the log data easily be set by the thread if needed, it will be left as None/null for now.</p>
</section>
<section id="cluster-management">
<h2>Cluster Management<a class="headerlink" href="#cluster-management" title="Link to this heading"></a></h2>
<p>The testbed server will automatically manage the testbed cluster for you.
When a testbed server is run in client mode, and makes a successful connection to the main testbed, the main testbed will keep track of the clients that have “joined” the cluster.
The main will populate the <cite>kvm-compose-config.json</cite> file in the testbed config folder dynamically, with the respective <cite>host.json</cite> files of each client.
On connection of the client, the client will push it’s own <cite>host.json</cite> to the main so the main knows how to use this client in it’s testbed deployments.</p>
<p>After the join request from the client, the main will periodically make a request to the client to see if it is still available.
If it is not available, the main will remove it from it’s cluster configuration <cite>kvm-compose-config.json</cite>.
Additionally, the clients will also periodically make a request to the main to see if it is still available.</p>
</section>
<section id="developer-notes">
<h2>Developer Notes<a class="headerlink" href="#developer-notes" title="Link to this heading"></a></h2>
<p>The server is implemented with the Axum web framework.
All code for the server is solely dealing with the API handlers and database connection.
Anything else, such as the business logic exists in the <cite>kvm-compose</cite> library which is imported.</p>
<p>The database provider is implemented with traits, so introducing a new database just requires implementing the trait functions.</p>
<p>This database connection is shared between all handlers and is wrapped with atomic read/write locks to ensure thread safety and prevent race conditions on the database (especially for the file based provider).</p>
<p>The <cite>setup.sh</cite> script will enable the server as a daemon, so if you want to run the server for development you will have to stop the service before you run you development version, as it shares the same port and the CLI will be connecting to this port.
Ideally we should make the port editable through environment variables for development purposes.</p>
<p>The server has a development mode, where there are checks for cargo’s debug mode.
This will change the logging level, and enable hot reloading of templates i.e. HTML for the GUI.
You can do this via (provide the server with root permissions):</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">#</span> <span class="pre">make</span> <span class="pre">sure</span> <span class="pre">youre</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">root</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">server</span> <span class="pre">crate</span> <span class="pre">i.e.</span>
<span class="pre">#</span> <span class="pre">testbed-os/kvm-compose/testbedos-server/</span>
<span class="pre">#</span> <span class="pre">then</span> <span class="pre">run</span> <span class="pre">the</span> <span class="pre">following</span>
<span class="pre">sudo</span> <span class="pre">-E</span> <span class="pre">bash</span> <span class="pre">-c</span>&#160; <span class="pre">'cargo</span> <span class="pre">run</span> <span class="pre">--</span> <span class="pre">main'</span> <span class="pre">$USER</span>
<span class="pre">`</span></code></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="TestbedOS Server" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="api.html" class="btn btn-neutral float-right" title="TestbedOS Server API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Bristol Cyber Security Group.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>